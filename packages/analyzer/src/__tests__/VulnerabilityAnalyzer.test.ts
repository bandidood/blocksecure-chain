import { VulnerabilityAnalyzer } from "../index";
import { SlitherAnalyzer } from "../analyzers/SlitherAnalyzer";
import { MythrilAnalyzer } from "../analyzers/MythrilAnalyzer";
import { Severity } from "../types";

jest.mock("../analyzers/SlitherAnalyzer");
jest.mock("../analyzers/MythrilAnalyzer");

describe("VulnerabilityAnalyzer", () => {
  let analyzer: VulnerabilityAnalyzer;
  let mockSlitherAnalyzer: jest.Mocked<SlitherAnalyzer>;
  let mockMythrilAnalyzer: jest.Mocked<MythrilAnalyzer>;

  beforeEach(() => {
    analyzer = new VulnerabilityAnalyzer();
    mockSlitherAnalyzer = (analyzer as any).slither;
    mockMythrilAnalyzer = (analyzer as any).mythril;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("checkAvailability", () => {
    it("should check if analyzers are available", async () => {
      mockSlitherAnalyzer.isAvailable = jest.fn().mockResolvedValue(true);
      mockMythrilAnalyzer.isAvailable = jest.fn().mockResolvedValue(false);

      const result = await analyzer.checkAvailability();

      expect(result).toEqual({
        slither: true,
        mythril: false,
      });
    });
  });

  describe("analyzeContract", () => {
    const mockSlitherResult = {
      contractPath: "test.sol",
      contractName: "Test",
      analyzer: "Slither",
      timestamp: new Date(),
      vulnerabilities: [
        {
          type: "REENTRANCY",
          severity: Severity.CRITICAL,
          title: "Reentrancy",
          description: "Potential reentrancy vulnerability",
        },
      ],
      summary: {
        total: 1,
        critical: 1,
        high: 0,
        medium: 0,
        low: 0,
        informational: 0,
      },
      isSecure: false,
      executionTime: 1000,
    };

    const mockMythrilResult = {
      contractPath: "test.sol",
      contractName: "Test",
      analyzer: "Mythril",
      timestamp: new Date(),
      vulnerabilities: [
        {
          type: "INTEGER_OVERFLOW",
          severity: Severity.HIGH,
          title: "Integer Overflow",
          description: "Potential integer overflow",
        },
      ],
      summary: {
        total: 1,
        critical: 0,
        high: 1,
        medium: 0,
        low: 0,
        informational: 0,
      },
      isSecure: false,
      executionTime: 2000,
    };

    it("should run available analyzers", async () => {
      mockSlitherAnalyzer.isAvailable = jest.fn().mockResolvedValue(true);
      mockSlitherAnalyzer.analyze = jest.fn().mockResolvedValue(mockSlitherResult);
      mockMythrilAnalyzer.isAvailable = jest.fn().mockResolvedValue(true);
      mockMythrilAnalyzer.analyze = jest.fn().mockResolvedValue(mockMythrilResult);

      const results = await analyzer.analyzeContract("test.sol");

      expect(results).toHaveLength(2);
      expect(mockSlitherAnalyzer.analyze).toHaveBeenCalledWith("test.sol", undefined);
      expect(mockMythrilAnalyzer.analyze).toHaveBeenCalledWith("test.sol", undefined);
    });

    it("should handle analyzer failures gracefully", async () => {
      mockSlitherAnalyzer.isAvailable = jest.fn().mockResolvedValue(true);
      mockSlitherAnalyzer.analyze = jest.fn().mockRejectedValue(new Error("Slither failed"));
      mockMythrilAnalyzer.isAvailable = jest.fn().mockResolvedValue(true);
      mockMythrilAnalyzer.analyze = jest.fn().mockResolvedValue(mockMythrilResult);

      const results = await analyzer.analyzeContract("test.sol");

      expect(results).toHaveLength(1);
      expect(results[0].analyzer).toBe("Mythril");
    });

    it("should throw error if no analyzers are available", async () => {
      mockSlitherAnalyzer.isAvailable = jest.fn().mockResolvedValue(false);
      mockMythrilAnalyzer.isAvailable = jest.fn().mockResolvedValue(false);

      await expect(analyzer.analyzeContract("test.sol")).rejects.toThrow(
        "No analyzers available"
      );
    });
  });

  describe("getCombinedAnalysis", () => {
    it("should combine results from multiple analyzers", async () => {
      const mockResults = [
        {
          contractPath: "test.sol",
          contractName: "Test",
          analyzer: "Slither",
          timestamp: new Date(),
          vulnerabilities: [
            {
              type: "REENTRANCY",
              severity: Severity.CRITICAL,
              title: "Reentrancy",
              description: "Reentrancy vulnerability",
            },
          ],
          summary: { total: 1, critical: 1, high: 0, medium: 0, low: 0, informational: 0 },
          isSecure: false,
          executionTime: 1000,
        },
        {
          contractPath: "test.sol",
          contractName: "Test",
          analyzer: "Mythril",
          timestamp: new Date(),
          vulnerabilities: [
            {
              type: "INTEGER_OVERFLOW",
              severity: Severity.HIGH,
              title: "Integer Overflow",
              description: "Integer overflow vulnerability",
            },
          ],
          summary: { total: 1, critical: 0, high: 1, medium: 0, low: 0, informational: 0 },
          isSecure: false,
          executionTime: 2000,
        },
      ];

      jest.spyOn(analyzer, "analyzeContract").mockResolvedValue(mockResults as any);

      const result = await analyzer.getCombinedAnalysis("test.sol");

      expect(result.analyzer).toBe("Combined");
      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.summary.total).toBe(2);
      expect(result.summary.critical).toBe(1);
      expect(result.summary.high).toBe(1);
      expect(result.executionTime).toBe(3000);
    });

    it("should remove duplicate vulnerabilities", async () => {
      const mockResults = [
        {
          contractPath: "test.sol",
          contractName: "Test",
          analyzer: "Slither",
          timestamp: new Date(),
          vulnerabilities: [
            {
              type: "REENTRANCY",
              severity: Severity.CRITICAL,
              title: "Reentrancy",
              description: "Same vulnerability",
            },
          ],
          summary: { total: 1, critical: 1, high: 0, medium: 0, low: 0, informational: 0 },
          isSecure: false,
          executionTime: 1000,
        },
        {
          contractPath: "test.sol",
          contractName: "Test",
          analyzer: "Mythril",
          timestamp: new Date(),
          vulnerabilities: [
            {
              type: "REENTRANCY",
              severity: Severity.CRITICAL,
              title: "Reentrancy",
              description: "Same vulnerability",
            },
          ],
          summary: { total: 1, critical: 1, high: 0, medium: 0, low: 0, informational: 0 },
          isSecure: false,
          executionTime: 2000,
        },
      ];

      jest.spyOn(analyzer, "analyzeContract").mockResolvedValue(mockResults as any);

      const result = await analyzer.getCombinedAnalysis("test.sol");

      expect(result.vulnerabilities).toHaveLength(1);
      expect(result.summary.total).toBe(1);
    });
  });
});
